README.md:the same should be made for FreeCAD libraries. You can also define appropriately the PYTHONPATH variable for both modules. 
README.md:If you are using FreeCAD in windows there is included a python distribution within FreeCAD distribution (by default located in C:\Program Files\FreeCAD 0.XX\bin\).
Suspicious_solids/Solid_original_52.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
Suspicious_solids/Solid_split_0.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
Suspicious_solids/Solid_split_52.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
Suspicious_solids/Solid_original_157.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
Suspicious_solids/Solid_original_0.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
Suspicious_solids/Solid_split_157.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
Suspicious_solids/Solid_original_148.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
Suspicious_solids/Solid_original_158.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
Suspicious_solids/Solid_split_158.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
Suspicious_solids/Solid_split_148.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/test.py:def set_input(inName, inpDir, outDir):
testing/test.py:vol_sdef    = True
testing/test.py:def get_input_list(folder, ext=None):
testing/test.py:def run_mcnp(path, inpFile):
testing/test.py:def clean(folder):
testing/test.py:def clean_dir(folder):
testing/test.py:def check_lost(outp):
testing/test.py:def get_mctal_values(mctal):
testing/test.py:def print_results(f, res, lost):
testing/test.py:def mk_geo_inp(inpDir, outDir):
testing/test.py:def process_mcnp_folder(outDir):
testing/test.py:def post_process(folder):
testing/inputSTEP/biseau.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/origSolid_4.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/origSolid_0.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/origSolid_5.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/origSolid_6.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/RJ24.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/sphereBarCyl1.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/P52.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/sphereBarCyl2.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/origSolid_2.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/origSolid_1.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/sphereBarRec.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Misc/cubo.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/tuboshueco.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/parte0.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/solid1.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/dobleCodo.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/codo.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/solid3.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/torus.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/solid2.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/codo2.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/codo2.stp:#387 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/placa1.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/placa2.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/parte1.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/rueda.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/TuboTorus.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/cylchaflan.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/Torus/placa3.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/dientes3.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/FWTBM1.step:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/placa2.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/SCDR_90.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/cylBox.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/DoubleCylinder/placa3.step:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/DoubleCylinder/placa2.step:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/DoubleCylinder/pieza2.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
testing/inputSTEP/DoubleCylinder/pieza1.stp:#9 = PRODUCT_DEFINITION_CONTEXT('part definition',#2,'design');
LICENSE.txt:This European Union Public Licence (the ‘EUPL’) applies to the Work (as defined
LICENSE.txt:defined below) has placed the following notice immediately following the
LICENSE.txt:  does not define the extent of modification or dependence on the Original Work
LICENSE.txt:Contributors. It is not a finished work and may therefore contain defects or
LICENSE.txt:limitation merchantability, fitness for a particular purpose, absence of defects
LICENSE.txt:defining obligations or services consistent with this Licence. However, if
LICENSE.txt:and only if You agree to indemnify, defend, and hold each Contributor harmless
scripts/colorCADmat.py:def getColor(num, vmin=0, vmax=rd):
scripts/colorCADmat.py:def setColorMaterial(documents):
scripts/config.ini:vol_sdef    = False
scripts/config.ini:# write the solid volume in mcnp cell definition (only for CAD solids)
scripts/config.ini:# write the material cards associated to material label present in the cell definition.
scripts/config.ini:# dummy material definition is hydrogen atom "Mx 1001 1"
scripts/config.ini:# Boolean simplification of the cell definition. Options are
scripts/config.ini:# No : no simplification (default)
scripts/config.ini:# if enclosures are defined in the CAD models, the voids cells of the enclosure are located in the mcnp outputfile 
scripts/config.ini:# change default tolerance values
scripts/config.ini:# define the general tolerance is the geouned conversion process
scripts/config.ini:# define the tolerance when comparing surfaces to check if there are the same surface
scripts/config.ini:# change default numeric format for numbers in MCNP input (float: X.Xf or scientific: X.Xe)
scripts/config.ini:# force to use cylinder instead of cone when additional surface should be added to Torus surface in the mcnp cell definition
scripts/config.ini:# by defaul n_plane_reverse = 10
scripts/config.ini:# Use specific conversion module for geometry defined with only cells defined by planes.
scripts/config.ini:# write ion MCNP format output plane definition with no-aligned 3 points belonging to the plane
scripts/config.ini:# enable a robust cell definition where other solid definition is rested from current solid definition.
.gitignore:profile_default/
tests_outputs/testing/inputSTEP/Misc/PiezaDavid/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/rails/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/tester/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/origSolid_1/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/origSolid_5/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/origSolid_0/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/sphereBarCyl1/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/origSolid_2/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/sphereBarCyl2/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/cubo/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/P52/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/RJ24/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/origSolid_4/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/origSolid_6/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Misc/sphereBarRec/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/large/Triangle/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/large/SCDR/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/FWTBM1/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/placa2/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/tubos/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/solid2/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/placa1/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/placa3/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/solid3/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/face2/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/dobleCodo/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/cylchaflan/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/parte0/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/example/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/placa2/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/torus/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/codo2/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/TuboTorus/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/tank/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/solid1/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/parte1/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/Design1/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/rueda/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/Torus/codo/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/BC/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/tuboshueco/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/dientes3/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/biseau/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/cylBox/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/DoubleCylinder/placa3/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/DoubleCylinder/pieza/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/DoubleCylinder/placa2/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/DoubleCylinder/pieza2/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/DoubleCylinder/placa/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/DoubleCylinder/pieza1/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/placa/config.ini:vol_sdef = True
tests_outputs/testing/inputSTEP/SCDR_90/config.ini:vol_sdef = True
.github/workflows/ci.yml:      defaults:
src/geouned/geouned/void/void.py:def void_generation(MetaList, EnclosureList, Surfaces, UniverseBox, setting, init):
src/geouned/geouned/void/void.py:def get_void_def(MetaList, Surfaces, Enclosure, setting, Lev0=False):
src/geouned/geouned/void/void.py:        mVoid.set_definition(vcell[0], simplify=True)
src/geouned/geouned/void/void.py:def set_graveyard_cell(Surfaces, UniverseBox):
src/geouned/geouned/void/void.py:    sphdef = BoolSequence(str(-id))
src/geouned/geouned/void/void.py:    sphdef.operator = "AND"
src/geouned/geouned/void/void.py:    sphdef.append(externalBox)
src/geouned/geouned/void/void.py:    mVoidSphIn.set_definition(sphdef)
src/geouned/geouned/void/void.py:    mVoidSphOut.set_definition(notsph)
src/geouned/geouned/void/void.py:def get_universe_complementary(Universe, Surfaces):
src/geouned/geouned/void/void.py:def void_commentLine(CellInfo):
src/geouned/geouned/void/void_box.py:from ..conversion import cell_definition as Conv
src/geouned/geouned/void/void_box.py:    def __init__(self, MetaSolids, Enclosure):
src/geouned/geouned/void/void_box.py:    def split(self, minSize=200):
src/geouned/geouned/void/void_box.py:    def piece_enclosure_split(self, Box, Tolerance=1.0e-13):
src/geouned/geouned/void/void_box.py:    def refine(self):
src/geouned/geouned/void/void_box.py:    def get_void_complementary(self, Surfaces, simplify="no"):
src/geouned/geouned/void/void_box.py:            Conv.cell_def(TempPieceEnclosure, Surfaces, UniverseBox)
src/geouned/geouned/void/void_box.py:            )  #  Cell to get complementary are null => Void is only box definition
src/geouned/geouned/void/void_box.py:                    # solid cell is not in void cell Void cell volume  => doesn't contribute to void definition
src/geouned/geouned/void/void_box.py:    def get_boxNumber(self):
src/geouned/geouned/void/void_box.py:    def getNumbers(self):
src/geouned/geouned/void/void_box.py:    def getBoundPlanes(self):
src/geouned/geouned/void/void_box.py:    def __removeExtraComp__(self, Obj, Box, mode="box"):
src/geouned/geouned/void/void_box.py:            Obj.set_definition(reducedDef)
src/geouned/geouned/void/void_box.py:    def __copyMeta__(self, m):
src/geouned/geouned/void/void_box.py:        Meta.set_definition(m.Definition.copy())
src/geouned/geouned/void/void_functions.py:def assign_enclosure(MetaList, NestedEnclosure):
src/geouned/geouned/void/void_functions.py:def select_solids(MetaList, LowLevelEnclosure, Enclosure):
src/geouned/geouned/void/void_functions.py:def update_void_list(offset, voidList, NestedEnclosure, sort_enclosure):
src/geouned/geouned/cuboid/translate.py:def commonEdge(face1, face2):
src/geouned/geouned/cuboid/translate.py:def isConvex(face1, face2, edge):
src/geouned/geouned/cuboid/translate.py:def removeElement(Faces, idf):
src/geouned/geouned/cuboid/translate.py:def is_inverted(solid):
src/geouned/geouned/cuboid/translate.py:def get_id(facein, Surfaces):
src/geouned/geouned/cuboid/translate.py:def translate(MetaList, Surfaces, UniverseBox, setting):
src/geouned/geouned/cuboid/translate.py:        set_definition(m, Surfaces)
src/geouned/geouned/cuboid/translate.py:def set_definition(metaObj, Surfaces):
src/geouned/geouned/cuboid/translate.py:    metaObj.set_definition(sDef)
src/geouned/geouned/utils/basic_functions_part2.py:def fuzzy(index, dtype, surf1, surf2, val, tol):
src/geouned/geouned/utils/basic_functions_part2.py:def is_same_plane(p1, p2, dtol=1e-6, atol=1e-6, relTol=True, fuzzy=(False, 0)):
src/geouned/geouned/utils/basic_functions_part2.py:def is_same_cylinder(cyl1, cyl2, dtol=1e-6, atol=1e-6, relTol=True, fuzzy=(False, 0)):
src/geouned/geouned/utils/basic_functions_part2.py:def is_same_cone(cone1, cone2, dtol=1e-6, atol=1e-6, relTol=True):
src/geouned/geouned/utils/basic_functions_part2.py:def is_same_sphere(sph1, sph2, tolerance=1e-6, relTol=True):
src/geouned/geouned/utils/basic_functions_part2.py:def is_same_torus(tor1, tor2, dtol=1e-6, atol=1e-6, relTol=True):
src/geouned/geouned/utils/basic_functions_part2.py:def is_duplicate_in_list(num_str1, i, lista):
src/geouned/geouned/utils/basic_functions_part2.py:def is_in_faces(face, Faces):
src/geouned/geouned/utils/basic_functions_part2.py:def is_in_faces2(face, Faces):
src/geouned/geouned/utils/boolean_function.py:    def __init__(self, definition=None, operator=None):
src/geouned/geouned/utils/boolean_function.py:        if definition:
src/geouned/geouned/utils/boolean_function.py:            self.set_def(definition)
src/geouned/geouned/utils/boolean_function.py:    def __str__(self):
src/geouned/geouned/utils/boolean_function.py:    def append(self, *seq):
src/geouned/geouned/utils/boolean_function.py:    def assign(self, Seq):
src/geouned/geouned/utils/boolean_function.py:    def update(self, Seq, pos):
src/geouned/geouned/utils/boolean_function.py:    def get_element(self, pos):
src/geouned/geouned/utils/boolean_function.py:    def copy(self):
src/geouned/geouned/utils/boolean_function.py:    def get_complementary(self):
src/geouned/geouned/utils/boolean_function.py:    def comp_operator(self):
src/geouned/geouned/utils/boolean_function.py:    def simplify(self, CT, depth=0):
src/geouned/geouned/utils/boolean_function.py:    def simplify_sequence(self, CT):
src/geouned/geouned/utils/boolean_function.py:    def do_factorize(self, valname, trueSet, falseSet):
src/geouned/geouned/utils/boolean_function.py:    def check(self, level0=False):
src/geouned/geouned/utils/boolean_function.py:    def substitute(self, var, val):
src/geouned/geouned/utils/boolean_function.py:    def clean(self, selfLevel=False):
src/geouned/geouned/utils/boolean_function.py:    def join_operators(self, selfLevel=False):
src/geouned/geouned/utils/boolean_function.py:    def get_sub_sequence(self, setIn):
src/geouned/geouned/utils/boolean_function.py:    def factorize(self, valname, trueSet, falseSet):
src/geouned/geouned/utils/boolean_function.py:    def evaluate(self, valueSet):
src/geouned/geouned/utils/boolean_function.py:    def set_def(self, expression):
src/geouned/geouned/utils/boolean_function.py:    def group_single(self):
src/geouned/geouned/utils/boolean_function.py:    def get_surfaces_numbers(self):
src/geouned/geouned/utils/boolean_function.py:    def level_update(self):
src/geouned/geouned/utils/boolean_function.py:def insert_in_sequence(Seq, trgt, nsrf, operator):
src/geouned/geouned/utils/boolean_function.py:def substitute_integer_element(Seq, target, newElement):
src/geouned/geouned/utils/boolean_function.py:def outer_terms(expression, value="number"):
src/geouned/geouned/utils/boolean_function.py:def redundant(m, geom):
src/geouned/geouned/utils/boolean_function.py:def is_integer(x):
src/geouned/geouned/utils/basic_functions_part1.py:def is_same_value(v1, v2, tolerance=1e-6):
src/geouned/geouned/utils/basic_functions_part1.py:def is_opposite(Vector1, Vector2, tolerance=1e-6):
src/geouned/geouned/utils/basic_functions_part1.py:def is_parallel(Vector1, Vector2, tolerance=1e-6):
src/geouned/geouned/utils/basic_functions_part1.py:def is_in_line(Point, Dir, Pnt_line, tolerance=1e-6):
src/geouned/geouned/utils/basic_functions_part1.py:def is_in_points(point, Points, tolerance=1e-5):
src/geouned/geouned/utils/basic_functions_part1.py:def is_in_edge(Edge1, Edge2, tolerance=1e-8):
src/geouned/geouned/utils/basic_functions_part1.py:def is_in_plane(Point, plane, dtolerance=1e-7):
src/geouned/geouned/utils/basic_functions_part1.py:def is_in_tolerance(val, tol, fuzzyLow, fuzzyHigh):
src/geouned/geouned/utils/basic_functions_part1.py:def sign_plane(Point, plane):
src/geouned/geouned/utils/basic_functions_part1.py:def points_to_coeffs(Points):
src/geouned/geouned/utils/basic_functions_part1.py:    def __init__(self, params, real=True):
src/geouned/geouned/utils/basic_functions_part1.py:    def __str__(self):
src/geouned/geouned/utils/basic_functions_part1.py:    def __init__(self, params, real=True):
src/geouned/geouned/utils/basic_functions_part1.py:    def __str__(self):
src/geouned/geouned/utils/basic_functions_part1.py:    def __init__(self, params, real=True):
src/geouned/geouned/utils/basic_functions_part1.py:    def __str__(self):
src/geouned/geouned/utils/basic_functions_part1.py:    def __init__(self, params, real=True):
src/geouned/geouned/utils/basic_functions_part1.py:    def __str__(self):
src/geouned/geouned/utils/basic_functions_part1.py:    def __init__(self, params):
src/geouned/geouned/utils/basic_functions_part1.py:    def __str__(self):
src/geouned/geouned/utils/basic_functions_part1.py:    def __init__(self, params):
src/geouned/geouned/utils/basic_functions_part1.py:    def __str__(self):
src/geouned/geouned/utils/boolean_solids.py:    def __init__(self, val=None, S1=None, S2=None):
src/geouned/geouned/utils/boolean_solids.py:    def get_transpose(self):
src/geouned/geouned/utils/boolean_solids.py:    def get_dependence(self):
src/geouned/geouned/utils/boolean_solids.py:    def __init__(self):
src/geouned/geouned/utils/boolean_solids.py:    def __str__(self):
src/geouned/geouned/utils/boolean_solids.py:    def add_element(self, k1, k2, val):
src/geouned/geouned/utils/boolean_solids.py:    def fill_missing_elements(self):
src/geouned/geouned/utils/boolean_solids.py:    def get_out_surfaces(self):
src/geouned/geouned/utils/boolean_solids.py:    def get_constraint_set(self, valname):
src/geouned/geouned/utils/boolean_solids.py:    def solid_in_box(self, Seq):  #  Sequence of the cell
src/geouned/geouned/utils/boolean_solids.py:def combine_diag_elements(d1, d2):
src/geouned/geouned/utils/boolean_solids.py:def build_c_table_from_solids(Box, SurfInfo, option="diag"):
src/geouned/geouned/utils/boolean_solids.py:def remove_extra_surfaces(CellSeq, CTable):
src/geouned/geouned/utils/boolean_solids.py:    # checking is make on solid cell definition to be removed from void cell
src/geouned/geouned/utils/boolean_solids.py:                # get reduced definition
src/geouned/geouned/utils/boolean_solids.py:def split_solid_fast(solid, surf, box):
src/geouned/geouned/utils/boolean_solids.py:def point_inside(solid):
src/geouned/geouned/utils/boolean_solids.py:def point_from_surface(solid):
src/geouned/geouned/utils/boolean_solids.py:def cut_box(Box):
src/geouned/geouned/utils/boolean_solids.py:def check_sign(solid, surf):
src/geouned/geouned/utils/geometry_gu.py:#  definition of GEOUNED objects to release memory
src/geouned/geouned/utils/geometry_gu.py:    def __init__(self, face):
src/geouned/geouned/utils/geometry_gu.py:    def __str__(self):
src/geouned/geouned/utils/geometry_gu.py:    def __init__(self, face, plane3Pts=False):
src/geouned/geouned/utils/geometry_gu.py:    def __init__(self, face):
src/geouned/geouned/utils/geometry_gu.py:    def __init__(self, face):
src/geouned/geouned/utils/geometry_gu.py:    def __init__(self, face):
src/geouned/geouned/utils/geometry_gu.py:    def __init__(self, face):
src/geouned/geouned/utils/geometry_gu.py:    def __init__(self, solid, plane3Pts=False):
src/geouned/geouned/utils/geometry_gu.py:        faces = define_list_face_gu(solid.Faces, plane3Pts)
src/geouned/geouned/utils/geometry_gu.py:    def __sameTorusSurf__(self, torusList):
src/geouned/geouned/utils/geometry_gu.py:    def __separateSurfaces__(self, faceList):
src/geouned/geouned/utils/geometry_gu.py:    def __mergeNoPeriodicUV__(self, parameter, faceList):
src/geouned/geouned/utils/geometry_gu.py:    def __mergePeriodicUV__(self, parameter, faceList):
src/geouned/geouned/utils/geometry_gu.py:    def __init__(self, face, Plane3Pts=False):
src/geouned/geouned/utils/geometry_gu.py:        self.Surface = define_surface(
src/geouned/geouned/utils/geometry_gu.py:    def tessellate(self, val, reset=False):
src/geouned/geouned/utils/geometry_gu.py:    def get_uv_nodes(self):
src/geouned/geouned/utils/geometry_gu.py:    def is_equal(self, face):
src/geouned/geouned/utils/geometry_gu.py:    def valueAt(self, u, v):
src/geouned/geouned/utils/geometry_gu.py:    def dist_to_shape(self, shape):
src/geouned/geouned/utils/geometry_gu.py:def define_list_face_gu(face_list, plane3Pts=False):
src/geouned/geouned/utils/geometry_gu.py:def define_surface(face, plane3Pts):
src/geouned/geouned/utils/geometry_gu.py:def list_surfaces(Surfaces):
src/geouned/geouned/utils/geometry_gu.py:        Faces.extend(define_surface(face) for face in elem)
src/geouned/geouned/utils/functions.py:def get_box(comp):
src/geouned/geouned/utils/functions.py:def make_plane(Plane, Boxin):
src/geouned/geouned/utils/functions.py:    def __init__(self, id, comsolid=None):
src/geouned/geouned/utils/functions.py:    def updateSolids(self, solidList):
src/geouned/geouned/utils/functions.py:    def setCADSolid(self):
src/geouned/geouned/utils/functions.py:    def setUniverseBox(self, UniverseBox):
src/geouned/geouned/utils/functions.py:    def setSonEnclosures(self, sonEnclosures):
src/geouned/geouned/utils/functions.py:    def set_definition(self, definition, simplify=False):
src/geouned/geouned/utils/functions.py:        if definition is None:
src/geouned/geouned/utils/functions.py:        self.Definition = definition
src/geouned/geouned/utils/functions.py:    def setFaces(self, faces):
src/geouned/geouned/utils/functions.py:    def setComments(self, comments):
src/geouned/geouned/utils/functions.py:    def setMaterial(self, material, rho=None, info=None):
src/geouned/geouned/utils/functions.py:    def setDilution(self, dilution):
src/geouned/geouned/utils/functions.py:    def checkIntersection(self, solid, dtolerance=1.0e-6, vtolerance=1e-10):
src/geouned/geouned/utils/functions.py:    def __init__(self, params, boundBox, Face=None):
src/geouned/geouned/utils/functions.py:            )  # plane point defined as the shortest distance to origin
src/geouned/geouned/utils/functions.py:            self.Surf = Plane3PtsParams(params[1])  # plane point defined with 3 points
src/geouned/geouned/utils/functions.py:    def buildSurface(self):
src/geouned/geouned/utils/functions.py:            print("Error: Type {} is not defined".format(self.Type))
src/geouned/geouned/utils/functions.py:    def __init__(self, surfaces=None, offset=0):
src/geouned/geouned/utils/functions.py:    def __str__(self):
src/geouned/geouned/utils/functions.py:    def getSurface(self, index):
src/geouned/geouned/utils/functions.py:    def delSurface(self, index):
src/geouned/geouned/utils/functions.py:    def extend(self, surface):
src/geouned/geouned/utils/functions.py:    def addPlane(self, plane, fuzzy=False):
src/geouned/geouned/utils/functions.py:    def addCylinder(self, cyl, fuzzy=False):
src/geouned/geouned/utils/functions.py:    def addCone(self, cone):
src/geouned/geouned/utils/functions.py:    def addSphere(self, sph):
src/geouned/geouned/utils/functions.py:    def addTorus(self, tor):
src/geouned/geouned/utils/functions.py:def splitBOP(solid, tools, tolerance, scale=0.1):
src/geouned/geouned/utils/q_form.py:def RotationMatrix(u, v):
src/geouned/geouned/utils/q_form.py:    # defintion of the axis of rotation
src/geouned/geouned/utils/q_form.py:def RotationMatrixAngleAxis(u, angle):
src/geouned/geouned/utils/q_form.py:    # defintion of the exis of rotation
src/geouned/geouned/utils/q_form.py:def q_form_cyl(Axis, Pos, rad):
src/geouned/geouned/utils/q_form.py:def q_form_cone(Axis, Pos, tan):
src/geouned/geouned/utils/Options/__init__.py:# default options values
src/geouned/geouned/utils/Options/__init__.py:force_cylinder = True  # Force using cylinders instead cones for auxillary surfaces of torus surface definition
src/geouned/geouned/utils/Options/__init__.py:Facets = False  # use alternative conversion module when geometry is defined by cells compound by only triangular plane faces
src/geouned/geouned/utils/Options/__init__.py:    False  # print 3 point plane definition in mcnp output as 3 points coordinates
src/geouned/geouned/utils/Options/__init__.py:forceNoOverlap = False  # force no overlaping cell definition. Adjacent cell definition are rested from current cell definition
src/geouned/geouned/utils/Options/__init__.py:}  # minimun face area to consider in cell definition
src/geouned/geouned/utils/Options/__init__.py:# Set default  attributes to Options class
src/geouned/geouned/utils/Options/__init__.py:# Set default  attributes to Tolerances class
src/geouned/geouned/utils/Options/__init__.py:# Set default  attributes to mcnp number format class
src/geouned/geouned/code_version.py:  - volInput card name substituted by vol_sdef card name
src/geouned/geouned/code_version.py:  - new card vol_card (values : True/False) used to insert the CAD cell volume into the cell definition
src/geouned/geouned/code_version.py:  - In "cell_definition.py" file. "is_opposite" function is call with rhe correct tolerance value instead of default value of the is_opposite function.  
src/geouned/geouned/code_version.py:  - Cylinders instead cones can be used  as auxillary surface for Torus surface definition 
src/geouned/geouned/code_version.py:  - new card "dummy_mat" to write dummy material card (associated to material labels present in cell definition) in input file.
src/geouned/geouned/code_version.py:  - implementation of new, more robust, cell definition, where adjacent solid cell definition is rested to current solid cell definition (forcing no overlaping cell).
src/geouned/geouned/write/string_functions.py:# define patterns to be found in string #
src/geouned/geouned/write/string_functions.py:def reverse_repl(m):
src/geouned/geouned/write/string_functions.py:def count_p(string):
src/geouned/geouned/write/string_functions.py:def redundant(m, geom):
src/geouned/geouned/write/string_functions.py:def remove_redundant(geom):
src/geouned/geouned/write/write_files.py:def write_geometry(UniverseBox, MetaList, Surfaces, code_setting):
src/geouned/geouned/write/write_files.py:        mcnpfile.set_sdef((outSphere, outBox))
src/geouned/geouned/write/write_files.py:        # Serpentfile.set_sdef((outSphere,outBox))
src/geouned/geouned/write/write_files.py:        # phitsfile.set_sdef_phits((phits_outSphere,phits_outBox))
src/geouned/geouned/write/functions.py:    def __init__(self, card, linesize=80, tabspace=6, fmt=""):
src/geouned/geouned/write/functions.py:    def extend(self, dataList):
src/geouned/geouned/write/functions.py:    def __init__(self, linesize=80, tabspace=6):
src/geouned/geouned/write/functions.py:    def add(self, string):
src/geouned/geouned/write/functions.py:    def delLastChar(self):
src/geouned/geouned/write/functions.py:    def wrapLine(self, offset=0):
src/geouned/geouned/write/functions.py:def change_surf_sign(surf, Seq):
src/geouned/geouned/write/functions.py:def write_mcnp_cell_def(Definition, tabspace=0, offset=0):
src/geouned/geouned/write/functions.py:    sdef = CellString(tabspace=tabspace)
src/geouned/geouned/write/functions.py:    sdef.add(strDef)
src/geouned/geouned/write/functions.py:    sdef.wrapLine(offset)
src/geouned/geouned/write/functions.py:    return sdef.str
src/geouned/geouned/write/functions.py:def write_serpent_cell_def(Definition, tabspace=0, offset=0):
src/geouned/geouned/write/functions.py:    sdef = CellString(tabspace=tabspace)
src/geouned/geouned/write/functions.py:    sdef.add(strDef)
src/geouned/geouned/write/functions.py:    sdef.wrapLine(offset)
src/geouned/geouned/write/functions.py:    return sdef.str
src/geouned/geouned/write/functions.py:def write_phits_cell_def(Definition, tabspace=0, offset=0):
src/geouned/geouned/write/functions.py:    sdef = CellString(tabspace=tabspace)
src/geouned/geouned/write/functions.py:    sdef.add(strDef)
src/geouned/geouned/write/functions.py:    sdef.wrapLine(offset)
src/geouned/geouned/write/functions.py:    return sdef.str
src/geouned/geouned/write/functions.py:def write_openmc_region(Definition, Wtype="XML"):
src/geouned/geouned/write/functions.py:def write_sequence_mcnp(Seq):
src/geouned/geouned/write/functions.py:def write_sequence_serpent(Seq):
src/geouned/geouned/write/functions.py:def write_sequence_phits(Seq):
src/geouned/geouned/write/functions.py:def write_sequence_openmc_xml(Seq):
src/geouned/geouned/write/functions.py:def write_sequence_openmc_py(Seq, prefix="S"):
src/geouned/geouned/write/functions.py:def mcnp_surface(id, Type, surf):
src/geouned/geouned/write/functions.py:    mcnp_def = ""
src/geouned/geouned/write/functions.py:            mcnp_def = """{:<6d} P   {P1[0]:{d}} {P1[1]:{d}} {P1[2]:{d}} 
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} PX  {:{x}}".format(id, D / 10.0, x=nf.P_xyz)
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} PY  {:{y}}".format(id, D / 10.0, y=nf.P_xyz)
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} PZ  {:{z}}".format(id, D / 10.0, z=nf.P_xyz)
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} P   {:{abc}} {:{abc}} {:{abc}} {:{d}}".format(
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} CX  {:{r}}".format(id, rad, r=nf.C_r)
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} C/X  {:{yz}} {:{yz}} {:{r}}".format(
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} CY  {:{r}}".format(id, rad, r=nf.C_r)
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} C/Y  {:{xz}} {:{xz}} {:{r}}".format(
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} CZ  {:{r}}".format(id, rad, r=nf.C_r)
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} C/Z  {:{xy}} {:{xy}} {:{r}}".format(
src/geouned/geouned/write/functions.py:            mcnp_def = """\
src/geouned/geouned/write/functions.py:        #    mcnp_def='%i  RCC  %13.7E %13.7E %13.7E %13.7E\n       %13.7E %13.7E %13.7E' %(id,Vx,Vy,Vz,Hx,Hy,Hz,rad)
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} KX  {:{x}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} K/X  {:{xyz}} {:{xyz}} {:{xyz}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} KY  {:{y}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} K/Y  {:{xyz}} {:{xyz}} {:{xyz}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} KZ  {:{z}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                mcnp_def = "{:<6d} K/Z  {:{xyz}} {:{xyz}} {:{xyz}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:            mcnp_def = """\
src/geouned/geouned/write/functions.py:            mcnp_def = "{:<6d} SO  {:{r}}".format(id, rad, r=nf.S_r)
src/geouned/geouned/write/functions.py:            mcnp_def = "{:<6d} S  {:{xyz}} {:{xyz}} {:{xyz}} {:{r}}".format(
src/geouned/geouned/write/functions.py:            mcnp_def = """\
src/geouned/geouned/write/functions.py:            mcnp_def = """\
src/geouned/geouned/write/functions.py:            mcnp_def = """\
src/geouned/geouned/write/functions.py:    return trim(mcnp_def, 80)
src/geouned/geouned/write/functions.py:def openmc_surface(Type, surf, outXML=True, quadricForm=False):
src/geouned/geouned/write/functions.py:def SerpentSurface(id, Type, surf):
src/geouned/geouned/write/functions.py:    Serpent_def = ""
src/geouned/geouned/write/functions.py:            Serpent_def = f"surf {id} plane {P1.x/10:{nf.P_d}} {P1.y/10:{nf.P_d}} {P1.z/10:{nf.P_d}}\n"
src/geouned/geouned/write/functions.py:            Serpent_def += (
src/geouned/geouned/write/functions.py:            Serpent_def += (
src/geouned/geouned/write/functions.py:                Serpent_def = f"surf {id} px {D/10:{nf.P_xyz}}"
src/geouned/geouned/write/functions.py:                Serpent_def = f"surf {id} py {D/10:{nf.P_xyz}}"
src/geouned/geouned/write/functions.py:                Serpent_def = f"surf {id} pz {D/10:{nf.P_xyz}}"
src/geouned/geouned/write/functions.py:                Serpent_def = f"surf {id} plane {A:{nf.P_d}} {B:{nf.P_d}} {C:{nf.P_d}} {D/10:{nf.P_d}}"
src/geouned/geouned/write/functions.py:            Serpent_def = (
src/geouned/geouned/write/functions.py:            Serpent_def = (
src/geouned/geouned/write/functions.py:            Serpent_def = f"surf {id} cylz {rad:{nf.C_r}}"
src/geouned/geouned/write/functions.py:            Serpent_def = """\
src/geouned/geouned/write/functions.py:            Serpent_def = "surf ckx {:{xyz}} {:{xyz}} {:{xyz}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:            Serpent_def = "surf cky {:{xyz}} {:{xyz}} {:{xyz}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:            Serpent_def = "surf ckz {:{xyz}} {:{xyz}} {:{xyz}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:            mcnp_def = """\
src/geouned/geouned/write/functions.py:        Serpent_def = f"surf {id} sph {pnt.x:{nf.S_xyz}} {pnt.y:{nf.S_xyz}} {pnt.z:{nf.S_xyz}} {rad:{nf.S_r}}"
src/geouned/geouned/write/functions.py:            Serpent_def = f"surf {id} torx {Pos.x:{nf.T_xyz}} {Pos.y:{nf.T_xyz}} {Pos.z:{nf.T_xyz}}\n"
src/geouned/geouned/write/functions.py:            Serpent_def += (
src/geouned/geouned/write/functions.py:            Serpent_def = f"surf {id} tory {Pos.x:{nf.T_xyz}} {Pos.y:{nf.T_xyz}} {Pos.z:{nf.T_xyz}}\n"
src/geouned/geouned/write/functions.py:            Serpent_def += (
src/geouned/geouned/write/functions.py:            Serpent_def = f"surf {id} torz {Pos.x:{nf.T_xyz}} {Pos.y:{nf.T_xyz}} {Pos.z:{nf.T_xyz}}\n"
src/geouned/geouned/write/functions.py:            Serpent_def += (
src/geouned/geouned/write/functions.py:    return Serpent_def
src/geouned/geouned/write/functions.py:def phits_surface(id, Type, surf):
src/geouned/geouned/write/functions.py:    phits_def = ""
src/geouned/geouned/write/functions.py:            phits_def = """{:<6d} P   {P1[0]:{d}} {P1[1]:{d}} {P1[2]:{d}} 
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} PX  {:{x}}".format(id, D / 10.0, x=nf.P_xyz)
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} PY  {:{y}}".format(id, D / 10.0, y=nf.P_xyz)
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} PZ  {:{z}}".format(id, D / 10.0, z=nf.P_xyz)
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} P   {:{abc}} {:{abc}} {:{abc}} {:{d}}".format(
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} CX  {:{r}}".format(id, rad, r=nf.C_r)
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} C/X  {:{yz}} {:{yz}} {:{r}}".format(
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} CY  {:{r}}".format(id, rad, r=nf.C_r)
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} C/Y  {:{xz}} {:{xz}} {:{r}}".format(
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} CZ  {:{r}}".format(id, rad, r=nf.C_r)
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} C/Z  {:{xy}} {:{xy}} {:{r}}".format(
src/geouned/geouned/write/functions.py:            phits_def = """\
src/geouned/geouned/write/functions.py:        #    mcnp_def='%i  RCC  %13.7E %13.7E %13.7E %13.7E\n       %13.7E %13.7E %13.7E' %(id,Vx,Vy,Vz,Hx,Hy,Hz,rad)
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} KX  {:{x}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} K/X  {:{xyz}} {:{xyz}} {:{xyz}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} KY  {:{y}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} K/Y  {:{xyz}} {:{xyz}} {:{xyz}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} KZ  {:{z}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:                phits_def = "{:<6d} K/Z  {:{xyz}} {:{xyz}} {:{xyz}} {:{t2}} {}".format(
src/geouned/geouned/write/functions.py:            phits_def = """\
src/geouned/geouned/write/functions.py:            phits_def = "{:<6d} SO  {:{r}}".format(id, rad, r=nf.S_r)
src/geouned/geouned/write/functions.py:            phits_def = "{:<6d} S  {:{xyz}} {:{xyz}} {:{xyz}} {:{r}}".format(
src/geouned/geouned/write/functions.py:            phits_def = """\
src/geouned/geouned/write/functions.py:            phits_def = """\
src/geouned/geouned/write/functions.py:            phits_def = """\
src/geouned/geouned/write/functions.py:    return trim(phits_def, 80)
src/geouned/geouned/write/functions.py:def trim(surfDef, lineLength=80):
src/geouned/geouned/write/functions.py:def cut_line(line, lineLength):
src/geouned/geouned/write/phits_format.py:    write_phits_cell_def,
src/geouned/geouned/write/phits_format.py:    def __init__(self, Meta, Surfaces, setting):
src/geouned/geouned/write/phits_format.py:        self.VolSDEF = setting["vol_sdef"]
src/geouned/geouned/write/phits_format.py:    def write_phits(self, filename):
src/geouned/geouned/write/phits_format.py:$ Need to change the dummy material definition(H2O1) to appropriate one(s) 
src/geouned/geouned/write/phits_format.py:    def __write_phits_header__(self, fileout):
src/geouned/geouned/write/phits_format.py:    def __write_phits_cell_block__(self):
src/geouned/geouned/write/phits_format.py:            print("Unified the inner void cell(s) definition")
src/geouned/geouned/write/phits_format.py:    def __step_file_label_chk__(self, filename):
src/geouned/geouned/write/phits_format.py:    def __write_phits_surface_block__(self):
src/geouned/geouned/write/phits_format.py:    def __write_phits_cells__(self, cell):
src/geouned/geouned/write/phits_format.py:        # if index is None objet not contain cell definition
src/geouned/geouned/write/phits_format.py:    def __write_phits_cells_uniVoidDef__(self, cell):
src/geouned/geouned/write/phits_format.py:        # if index is None objet not contain cell definition
src/geouned/geouned/write/phits_format.py:        # Grayveyard sphere is redefined as the boundary surface 
src/geouned/geouned/write/phits_format.py:        # To exclude solid cell(s) from the inner void's defenition,
src/geouned/geouned/write/phits_format.py:        # is appended to the new inner void cell definition
src/geouned/geouned/write/phits_format.py:                    one_mervoid_str = "VOID CELL {} merged, so the auto-genarated void definition is eliminated\n"
src/geouned/geouned/write/phits_format.py:                    some_mervoid_str = "VOID CELLs {}-{} merged, so the auto-genarated void definitions are eliminated\n"
src/geouned/geouned/write/phits_format.py:        # comment out some part in the def __write_phits__Volume_block__() section also.       
src/geouned/geouned/write/phits_format.py:    def __write_phits_surfaces__(self, surface):
src/geouned/geouned/write/phits_format.py:        phits_def = phits_surface(surface.Index, surface.Type, surface.Surf)
src/geouned/geouned/write/phits_format.py:        if phits_def:
src/geouned/geouned/write/phits_format.py:            phits_def += "\n"
src/geouned/geouned/write/phits_format.py:            self.inpfile.write(phits_def)
src/geouned/geouned/write/phits_format.py:    def __write_phits_source_block__(self):
src/geouned/geouned/write/phits_format.py:    def __write_phits__Volume_block__(self):
src/geouned/geouned/write/phits_format.py:    def __cellFormat__(self, Definition, offset=11):
src/geouned/geouned/write/phits_format.py:        return write_phits_cell_def(Definition, tabspace=11, offset=offset)
src/geouned/geouned/write/phits_format.py:    def __new_InnerVoid_Def__(self, innerSolidCells, Definition, offset=11):
src/geouned/geouned/write/phits_format.py:        strdef = CellString(tabspace=11)
src/geouned/geouned/write/phits_format.py:        strdef.add(newInnerVoidDef + innerSolidCells)
src/geouned/geouned/write/phits_format.py:        strdef.wrapLine(offset)
src/geouned/geouned/write/phits_format.py:        return strdef.str
src/geouned/geouned/write/phits_format.py:    def __optionFormat__(self, cell):
src/geouned/geouned/write/phits_format.py:    def __commentFormat__(self, cComment, mComment=None):
src/geouned/geouned/write/phits_format.py:    def __commentLine__(self, lineComment):
src/geouned/geouned/write/phits_format.py:    def __getSurfaceTable__(self):
src/geouned/geouned/write/phits_format.py:    def __simplifyPlanes__(self, Surfaces):
src/geouned/geouned/write/phits_format.py:    def __sortedSurfaces__(self, Surfaces):
src/geouned/geouned/write/phits_format.py:    def __change_surf_sign__(self, p):
src/geouned/geouned/write/phits_format.py:                "{} Surface {} not used in cell definition)".format(p.Type, p.Index),
src/geouned/geouned/write/phits_format.py:    def __get_solidCellVolume__(self):
src/geouned/geouned/write/additional_files.py:def comments_write(name, MetaList):
src/geouned/geouned/write/additional_files.py:def summary_write(name, MetaList):
src/geouned/geouned/write/mcnp_format.py:from .functions import CardLine, mcnp_surface, change_surf_sign, write_mcnp_cell_def
src/geouned/geouned/write/mcnp_format.py:    def __init__(self, Meta, Surfaces, setting):
src/geouned/geouned/write/mcnp_format.py:        self.VolSDEF = setting["vol_sdef"]
src/geouned/geouned/write/mcnp_format.py:    def set_sdef(self, data):
src/geouned/geouned/write/mcnp_format.py:            sdef = "SDEF PAR={} NRM=-1 SUR={} WGT={:13.7e} DIR=d1\n".format(
src/geouned/geouned/write/mcnp_format.py:            self.SDEF_sphere = (sdef, SI1, SP1)
src/geouned/geouned/write/mcnp_format.py:        sdef = "SDEF PAR={} X=D1 Y=D2 Z=D3 \n".format(self.part)
src/geouned/geouned/write/mcnp_format.py:        self.SDEF_box = (sdef, SI1, SI2, SI3, SP1, SP2, SP3)
src/geouned/geouned/write/mcnp_format.py:    def write_input(self, filename):
src/geouned/geouned/write/mcnp_format.py:    def __write_header__(self, fileout):
src/geouned/geouned/write/mcnp_format.py:    def __write_cell_block__(self):
src/geouned/geouned/write/mcnp_format.py:    def __write_surface_block__(self):
src/geouned/geouned/write/mcnp_format.py:    def __write_cells__(self, cell):
src/geouned/geouned/write/mcnp_format.py:        # if index is None objet not contain cell definition
src/geouned/geouned/write/mcnp_format.py:    def __write_surfaces__(self, surface):
src/geouned/geouned/write/mcnp_format.py:        mcnp_def = mcnp_surface(surface.Index, surface.Type, surface.Surf)
src/geouned/geouned/write/mcnp_format.py:        if mcnp_def:
src/geouned/geouned/write/mcnp_format.py:            mcnp_def += "\n"
src/geouned/geouned/write/mcnp_format.py:            self.inpfile.write(mcnp_def)
src/geouned/geouned/write/mcnp_format.py:    def __write_source_block__(self):
src/geouned/geouned/write/mcnp_format.py:    def __cellFormat__(self, Definition, offset=11):
src/geouned/geouned/write/mcnp_format.py:        return write_mcnp_cell_def(Definition, tabspace=11, offset=offset)
src/geouned/geouned/write/mcnp_format.py:    def __optionFormat__(self, cell):
src/geouned/geouned/write/mcnp_format.py:    def __commentFormat__(self, cComment, mComment=None):
src/geouned/geouned/write/mcnp_format.py:    def __commentLine__(self, lineComment):
src/geouned/geouned/write/mcnp_format.py:    def __getSurfaceTable__(self):
src/geouned/geouned/write/mcnp_format.py:    def __simplifyPlanes__(self, Surfaces):
src/geouned/geouned/write/mcnp_format.py:    def __sortedSurfaces__(self, Surfaces):
src/geouned/geouned/write/mcnp_format.py:    def __change_surf_sign__(self, p):
src/geouned/geouned/write/mcnp_format.py:                "{} Surface {} not used in cell definition)".format(p.Type, p.Index),
src/geouned/geouned/write/mcnp_format.py:    def __get_solidCellVolume__(self):
src/geouned/geouned/write/serpent_format.py:from .functions import SerpentSurface, change_surf_sign, write_serpent_cell_def
src/geouned/geouned/write/serpent_format.py:    def __init__(self, Meta, Surfaces, setting):
src/geouned/geouned/write/serpent_format.py:        self.VolSDEF = setting["vol_sdef"]
src/geouned/geouned/write/serpent_format.py:    # def setSRC(self,data):
src/geouned/geouned/write/serpent_format.py:    #       sdef     = f'src point {self.part}\n'
src/geouned/geouned/write/serpent_format.py:    #       self.src_sphere = (sdef)
src/geouned/geouned/write/serpent_format.py:    #     sdef = 'SDEF PAR={} X=D1 Y=D2 Z=D3 \n'.format(self.part)
src/geouned/geouned/write/serpent_format.py:    #     self.SDEF_box    = (sdef,SI1,SI2,SI3,SP1,SP2,SP3)
src/geouned/geouned/write/serpent_format.py:    def write_input(self, filename):
src/geouned/geouned/write/serpent_format.py:    def __write_header__(self, fileout):
src/geouned/geouned/write/serpent_format.py:    def __write_surface_block__(self):
src/geouned/geouned/write/serpent_format.py:    def __write_cell_block__(self):
src/geouned/geouned/write/serpent_format.py:    def __write_cells__(self, cell):
src/geouned/geouned/write/serpent_format.py:        # If index is None, the object does not contain cell definition
src/geouned/geouned/write/serpent_format.py:    def __write_surfaces__(self, surface):
src/geouned/geouned/write/serpent_format.py:        Serpent_def = SerpentSurface(surface.Index, surface.Type, surface.Surf)
src/geouned/geouned/write/serpent_format.py:        if Serpent_def:
src/geouned/geouned/write/serpent_format.py:            Serpent_def += "\n"
src/geouned/geouned/write/serpent_format.py:            self.inpfile.write(Serpent_def)
src/geouned/geouned/write/serpent_format.py:    def __write_source_block__(self):
src/geouned/geouned/write/serpent_format.py:    def __cellFormat__(self, Definition, offset=11):
src/geouned/geouned/write/serpent_format.py:        return write_serpent_cell_def(Definition, tabspace=11, offset=offset)
src/geouned/geouned/write/serpent_format.py:    # Volumes only defined on tally cards.
src/geouned/geouned/write/serpent_format.py:    # def __optionFormat__(self,cell):
src/geouned/geouned/write/serpent_format.py:    def comment_format(self, cComment, mComment=None):
src/geouned/geouned/write/serpent_format.py:    def comment_line(self, lineComment):
src/geouned/geouned/write/serpent_format.py:    def __getSurfaceTable__(self):
src/geouned/geouned/write/serpent_format.py:    def __simplifyPlanes__(self, Surfaces):
src/geouned/geouned/write/serpent_format.py:    def __sortedSurfaces__(self, Surfaces):
src/geouned/geouned/write/serpent_format.py:    def __change_surf_sign__(self, p):
src/geouned/geouned/write/serpent_format.py:                "{} Surface {} not used in cell definition)".format(p.Type, p.Index),
src/geouned/geouned/write/serpent_format.py:    def __get_solidCellVolume__(self):
src/geouned/geouned/write/openmc_format.py:    def __init__(self, Meta, Surfaces, setting):
src/geouned/geouned/write/openmc_format.py:    def write_xml(self, filename):
src/geouned/geouned/write/openmc_format.py:    def __write_xml_header__(self, fileout):
src/geouned/geouned/write/openmc_format.py:    def __write_xml_cell_block__(self):
src/geouned/geouned/write/openmc_format.py:    def __write_xml_surface_block__(self):
src/geouned/geouned/write/openmc_format.py:    def __write_xml_cells__(self, cell):
src/geouned/geouned/write/openmc_format.py:    def __write_xml_surfaces__(self, surface, boundary=False):
src/geouned/geouned/write/openmc_format.py:    def write_py(self, filename):
src/geouned/geouned/write/openmc_format.py:        self.inpfile.write("# Cell definition \n")
src/geouned/geouned/write/openmc_format.py:    def __write_py_header__(self, fileout):
src/geouned/geouned/write/openmc_format.py:    def __write_py_materials__(self):
src/geouned/geouned/write/openmc_format.py:    def __write_py_surface_block__(self):
src/geouned/geouned/write/openmc_format.py:    def __write_py_surfaces__(self, surface, boundary=False):
src/geouned/geouned/write/openmc_format.py:    def __write_py_cell_block__(self):
src/geouned/geouned/write/openmc_format.py:    def __write_py_cells__(self, cell):
src/geouned/geouned/write/openmc_format.py:    def __getSurfaceTable__(self):
src/geouned/geouned/write/openmc_format.py:    def __simplifyPlanes__(self, Surfaces):
src/geouned/geouned/write/openmc_format.py:    def __sortedSurfaces__(self, Surfaces):
src/geouned/geouned/write/openmc_format.py:    def __change_surf_sign__(self, p):
src/geouned/geouned/write/openmc_format.py:                "{} Surface {} not used in cell definition)".format(p.Type, p.Index),
src/geouned/geouned/load_file/load_functions.py:def GetLabel(label):
src/geouned/geouned/load_file/load_functions.py:def getCommentTree(obj):
src/geouned/geouned/load_file/load_functions.py:def joinEnvelopes(MetaList):
src/geouned/geouned/load_file/load_functions.py:def fuseMetaObj(MetaList, init, end):
src/geouned/geouned/load_file/load_functions.py:def checkCADFileMaterial(Material, mdict):
src/geouned/geouned/load_file/load_functions.py:def setEnclosureSolidList(MetaList):
src/geouned/geouned/load_file/load_functions.py:    """Function to define DataList list."""
src/geouned/geouned/load_file/load_functions.py:def RemoveEnclosure(MetaList):
src/geouned/geouned/load_file/load_functions.py:def setEnclosureLevels(EnclosureList):
src/geouned/geouned/load_file/load_functions.py:def checkEnclosure(FreeCAD_doc, EnclosureList):
src/geouned/geouned/load_file/load_functions.py:def checkOverlap(enclosures):
src/geouned/geouned/load_file/load_functions.py:def updateTree(Tree, level):
src/geouned/geouned/load_file/load_functions.py:def set_docOptions():
src/geouned/geouned/load_file/load_functions.py:def checkIndex(docList, index, returnObject=False):
src/geouned/geouned/load_file/load_functions.py:def nextIndex(docList, lastIndex=None):
src/geouned/geouned/load_file/load_functions.py:def solidGenerator(doclist):
src/geouned/geouned/load_file/load_step.py:def extractMaterials(filename):
src/geouned/geouned/load_file/load_step.py:def LoadCAD(filename, matfilename, defaultMat=[], comp_solids=True):
src/geouned/geouned/load_file/load_step.py:            print("Material definition file {} does not exist.".format(matfilename))
src/geouned/geouned/load_file/load_step.py:                    # Search for material definition in tree
src/geouned/geouned/load_file/load_step.py:                    # Search for dilution definition in tree
src/geouned/geouned/load_file/load_step.py:                        if defaultMat:
src/geouned/geouned/load_file/load_step.py:                            MetaList[isolid].setMaterial(*defaultMat)
src/geouned/geouned/conversion/cell_definition.py:# Module for Cell definiton #
src/geouned/geouned/conversion/cell_definition.py:def get_id(facein, Surfaces):
src/geouned/geouned/conversion/cell_definition.py:def is_inverted(solid):
src/geouned/geouned/conversion/cell_definition.py:def gen_plane(face, solid):
src/geouned/geouned/conversion/cell_definition.py:def get_closed_ranges(solid, face_index):
src/geouned/geouned/conversion/cell_definition.py:def get_intervals(UNodes):
src/geouned/geouned/conversion/cell_definition.py:def get_u_value_boundary(solid, face_index, myIndex):
src/geouned/geouned/conversion/cell_definition.py:def gen_plane_sphere(face, solid):
src/geouned/geouned/conversion/cell_definition.py:def gen_plane_cylinder(face, solid):
src/geouned/geouned/conversion/cell_definition.py:                    f"Warning: {str(Surf)} surface removed from cell definition. Face area < Min area ({face2.Area} < {tol.min_area}) "
src/geouned/geouned/conversion/cell_definition.py:            print("Error in the additional place definition")
src/geouned/geouned/conversion/cell_definition.py:def gen_plane_cylinder_old(face, solid):
src/geouned/geouned/conversion/cell_definition.py:                    f"Warning: {str(Surf)} surface removed from cell definition. Face area < Min area ({face2.Area} < {tol.min_area}) "
src/geouned/geouned/conversion/cell_definition.py:            print("Error in the additional place definition")
src/geouned/geouned/conversion/cell_definition.py:def gen_plane_cone(face, solid):
src/geouned/geouned/conversion/cell_definition.py:                    f"Warning: {str(Surf)} surface removed from cell definition. Face area < Min area ({face2.Area} < {tol.min_area}) "
src/geouned/geouned/conversion/cell_definition.py:            print("Error in the additional place definition")
src/geouned/geouned/conversion/cell_definition.py:def gen_plane_cone_old(face, solid):
src/geouned/geouned/conversion/cell_definition.py:                    f"Warning: {str(Surf)} surface removed from cell definition. Face area < Min area ({face2.Area} < {tol.min_area}) "
src/geouned/geouned/conversion/cell_definition.py:            print("Error in the additional place definition")
src/geouned/geouned/conversion/cell_definition.py:def gen_torus_annex_u_planes(face, Uparams):
src/geouned/geouned/conversion/cell_definition.py:def gen_torus_annex_u_planes_org(face, Uparams):
src/geouned/geouned/conversion/cell_definition.py:def gen_torus_annex_v_surface(face, Vparams, force_cylinder=False):
src/geouned/geouned/conversion/cell_definition.py:def cell_def(metaObj, Surfaces, UniverseBox):
src/geouned/geouned/conversion/cell_definition.py:                        f"Warning: {surfaceType} surface removed from cell definition. Face area < Min area ({face.Area} < {tol.min_area}) "
src/geouned/geouned/conversion/cell_definition.py:    metaObj.set_definition(PieceDef)
src/geouned/geouned/conversion/cell_definition.py:def get_surf_value(Definition, reverse=False):
src/geouned/geouned/conversion/cell_definition.py:def append_comp(newCell, cellDef, cellCAD, metaComplementary):
src/geouned/geouned/conversion/cell_definition.py:def no_overlapping_cell(metaList, Surfaces):
src/geouned/geouned/conversion/cell_definition.py:            m.set_definition(newDef)
src/geouned/geouned/conversion/cell_definition.py:def extra_plane_cyl_face(face, Box, Surfaces):
src/geouned/geouned/conversion/cell_definition.py:def add_cone_plane(Definition, conesList, Surfaces, UniverseBox):
src/geouned/geouned/decompose/decom_one.py:from ..conversion import cell_definition as CD
src/geouned/geouned/decompose/decom_one.py:def split_full_cylinder(solid):
src/geouned/geouned/decompose/decom_one.py:def cut_full_cylinder(solid):
src/geouned/geouned/decompose/decom_one.py:def gen_plane(pos, normal, diag):
src/geouned/geouned/decompose/decom_one.py:def cyl_bound_planes(face, boundBox):
src/geouned/geouned/decompose/decom_one.py:def torus_bound_planes(face, boundBox):
src/geouned/geouned/decompose/decom_one.py:def plane_spline_curve(edge):
src/geouned/geouned/decompose/decom_one.py:def extract_surfaces(solid, kind, UniverseBox, MakeObj=False):
src/geouned/geouned/decompose/decom_one.py:def is_already_in_planes(plane, Array):
src/geouned/geouned/decompose/decom_one.py:def contiguous_face(face1, face2):
src/geouned/geouned/decompose/decom_one.py:def SameFaces(Faces):
src/geouned/geouned/decompose/decom_one.py:def gen_plane_cylinder(face, solid):
src/geouned/geouned/decompose/decom_one.py:            print("Error in the additional plane definition")
src/geouned/geouned/decompose/decom_one.py:def gen_plane_cone(face, solid):
src/geouned/geouned/decompose/decom_one.py:            print("Error in the additional plane definition")
src/geouned/geouned/decompose/decom_one.py:def plane_2nd_order(SolidGu, face, flag_inv, convex=True):
src/geouned/geouned/decompose/decom_one.py:def split_planes(Solids, UniverseBox, newVersion=True):
src/geouned/geouned/decompose/decom_one.py:def split_planes_new(Solids, UniverseBox):
src/geouned/geouned/decompose/decom_one.py:    # Cut with real planes defining solid faces
src/geouned/geouned/decompose/decom_one.py:def split_planes_org(Solids, UniverseBox):
src/geouned/geouned/decompose/decom_one.py:    def __init__(self, plane):
src/geouned/geouned/decompose/decom_one.py:    def append(self, plane):
src/geouned/geouned/decompose/decom_one.py:    def sort(self):
src/geouned/geouned/decompose/decom_one.py:def sort_planes(PlaneList, sortElements=False):
src/geouned/geouned/decompose/decom_one.py:def split_p_planes_new(solid, UniverseBox):
src/geouned/geouned/decompose/decom_one.py:def split_p_planes_org(solid, UniverseBox):
src/geouned/geouned/decompose/decom_one.py:def split_2nd_order(Solids, UniverseBox):
src/geouned/geouned/decompose/decom_one.py:def split_2nd_order_planes(Solids):
src/geouned/geouned/decompose/decom_one.py:def split_2nd_o_plane(solid):
src/geouned/geouned/decompose/decom_one.py:def remove_solids(Solids):
src/geouned/geouned/decompose/decom_one.py:def split_component(solidShape, UniverseBox):
src/geouned/geouned/decompose/decom_one.py:def split_solid(solidShape, UniverseBox):
src/geouned/geouned/__init__.py:from .conversion import cell_definition as Conv
src/geouned/geouned/__init__.py:from .write.functions import write_mcnp_cell_def
src/geouned/geouned/__init__.py:    def __init__(self, title="Geouned conversion"):
src/geouned/geouned/__init__.py:        self.__dict__["vol_sdef"] = False
src/geouned/geouned/__init__.py:    def set_options(self):
src/geouned/geouned/__init__.py:                        "vol_sdef",
src/geouned/geouned/__init__.py:    def set(self, kwrd, value):
src/geouned/geouned/__init__.py:            "vol_sdef",
src/geouned/geouned/__init__.py:    def start(self):
src/geouned/geouned/__init__.py:                cones = Conv.cell_def(m, Surfaces, UniverseBox)
src/geouned/geouned/__init__.py:                cones = Conv.cell_def(m, Surfaces, UniverseBox)
src/geouned/geouned/__init__.py:            # if a solid belong to several enclosure, its definition will be written
src/geouned/geouned/__init__.py:        # add plane definition to cone
src/geouned/geouned/__init__.py:def decompose_solids(MetaList, Surfaces, UniverseBox, setting, meta):
src/geouned/geouned/__init__.py:def update_comment(meta, idLabel):
src/geouned/geouned/__init__.py:def process_cones(MetaList, coneInfo, Surfaces, UniverseBox):
src/geouned/geouned/__init__.py:def get_universe(MetaList):
src/geouned/geouned/__init__.py:def print_warning_solids(warnSolids, warnEnclosures):
src/geouned/geouned/__init__.py:        fic = open("Warning_Solids_definition.txt", "w")
src/geouned/geouned/__init__.py:            lines += "{}\n".format(write_mcnp_cell_def(sol.Definition))
src/geouned/geouned/__init__.py:            lines += "{}\n".format(write_mcnp_cell_def(sol.Definition))
src/geouned/geouned/__init__.py:def join_meta_lists(MList):
src/geouned/geouned/__init__.py:def exclude_cells(MetaList, labelList):
src/geouned/geouned/__init__.py:def sort_enclosure(MetaList, MetaVoid, offSet=0):
src/geouned/georeverse/modules/build_solid_cell.py:def get_part(slist):
src/geouned/georeverse/modules/build_solid_cell.py:def build_solid(cell, boundBox, mode="oneByOne", simplify=False):
src/geouned/georeverse/modules/build_solid_cell.py:    # cell.definition = BoolSequence(cell.definition.str)
src/geouned/georeverse/modules/build_solid_cell.py:    cell.clean_undefined()
src/geouned/georeverse/modules/build_solid_cell.py:def build_depth(cell, cutShape, mode, baseBox, simplify=False, loop=0):
src/geouned/georeverse/modules/build_solid_cell.py:    seq = cell.definition
src/geouned/georeverse/modules/build_solid_cell.py:        # CS.base.exportStep('CS_{}_{}.stp'.format(i,str(cell.definition)))
src/geouned/georeverse/modules/build_solid_cell.py:        # cell.definition.simplify(CTable)
src/geouned/georeverse/modules/build_solid_cell.py:        cell.definition.group_single()
src/geouned/georeverse/modules/build_solid_cell.py:        if type(cell.definition.elements) is not bool:
src/geouned/georeverse/modules/build_solid_cell.py:            if cell.definition.level == 0:
src/geouned/georeverse/modules/build_solid_cell.py:                tmp = BoolSequence(operator=cell.definition.operator)
src/geouned/georeverse/modules/build_solid_cell.py:                tmp.append(cell.definition)
src/geouned/georeverse/modules/build_solid_cell.py:                cell.definition = tmp
src/geouned/georeverse/modules/build_solid_cell.py:                for e in cell.definition.elements:
src/geouned/georeverse/modules/build_solid_cell.py:                for e in cell.definition.elements:
src/geouned/georeverse/modules/build_solid_cell.py:        elif cell.definition.elements:
src/geouned/georeverse/modules/build_solid_cell.py:def build_solid_parts(cell, base, mode):
src/geouned/georeverse/modules/build_solid_cell.py:    # print(cell.definition)
src/geouned/georeverse/modules/build_solid_cell.py:        if cell.definition.operator == "OR" and False:
src/geouned/georeverse/modules/build_solid_cell.py:            Def = cell.definition
src/geouned/georeverse/modules/build_solid_cell.py:            cell.definition = cell.definition.get_complementary()
src/geouned/georeverse/modules/build_solid_cell.py:            cell.definition = Def
src/geouned/georeverse/modules/build_solid_cell.py:        # name=''.join(str(cell.definition))
src/geouned/georeverse/modules/build_solid_cell.py:def fuse_solid(parts):
src/geouned/georeverse/modules/build_solid_cell.py:def noOR(Seq):
src/geouned/georeverse/modules/build_cad.py:def build_cad(UnivCell, data, config):
src/geouned/georeverse/modules/build_cad.py:    # read all surfaces definition
src/geouned/georeverse/modules/build_cad.py:    #    print(UniverseCells[0][120].definition.str)
src/geouned/georeverse/modules/build_cad.py:    #    simply = BoolSequence(UniverseCells[0][70].definition.str)
src/geouned/georeverse/modules/build_cad.py:def interferencia(container, cell, mode="slice"):
src/geouned/georeverse/modules/build_cad.py:def assign_surface_to_cell(UniverseCells, modelSurfaces):
src/geouned/georeverse/modules/build_cad.py:def get_universe_containers(levels, Universes):
src/geouned/georeverse/modules/build_cad.py:def build_universe(
src/geouned/georeverse/modules/build_cad.py:            if type(NTcell.definition) is not BoolSequence:
src/geouned/georeverse/modules/build_cad.py:                NTcell.definition = BoolSequence(NTcell.definition.str)
src/geouned/georeverse/modules/build_cad.py:def make_tree(CADdoc, CADCells):
src/geouned/georeverse/modules/split_function.py:    def __init__(self, base, knownSurf={}):
src/geouned/georeverse/modules/split_function.py:def join_base(baseList):
src/geouned/georeverse/modules/split_function.py:def split_solid(base, surfacesCut, cellObj, solidTool=False, tolerance=0.01):  # 1e-2
src/geouned/georeverse/modules/split_function.py:    # will require more splitting with the others surfaces defining the cell.
src/geouned/georeverse/modules/split_function.py:        # inSolid = cellObj.definition.evaluate(fullPos)
src/geouned/georeverse/modules/split_function.py:        inSolid = cellObj.definition.evaluate(pos)
src/geouned/georeverse/modules/split_function.py:        #  print(cellObj.definition)
src/geouned/georeverse/modules/split_function.py:        #  name = str(cellObj.definition)
src/geouned/georeverse/modules/split_function.py:def update_surfaces_values(position, surfaces, knownSurf):
src/geouned/georeverse/modules/split_function.py:def space_decomposition(solids, surfaces):
src/geouned/georeverse/modules/split_function.py:def point_inside(solid):
src/geouned/georeverse/modules/split_function.py:def cut_box(Box):
src/geouned/georeverse/modules/split_function.py:def surface_side(p, surf):
src/geouned/georeverse/modules/split_function.py:def btw_p_planes(p, p0, v):
src/geouned/georeverse/modules/split_function.py:def fuse_solid(parts):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def __init__(self, definition=None, operator=None):
src/geouned/georeverse/modules/utils/booleanFunction.py:        if definition:
src/geouned/georeverse/modules/utils/booleanFunction.py:            self.set_def(definition)
src/geouned/georeverse/modules/utils/booleanFunction.py:    def __str__(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def append(self, *seq):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def assign(self, Seq):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def copy(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def get_complementary(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def comp_operator(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def simplify(self, CT, loop=0):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def check(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def substitute(self, var, val):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def remove_surf(self, name):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def clean(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def join_operators(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def factorize(self, valname, CT=None):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def evaluate_newbad(self, valueSet, CT=None):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def evaluate(self, valueSet, CT=None):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def set_def(self, expression):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def group_single(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def same_operator(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def get_surfaces_numbers(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:    def level_update(self):
src/geouned/georeverse/modules/utils/booleanFunction.py:def outer_terms(expression, value="number"):
src/geouned/georeverse/modules/utils/booleanFunction.py:def redundant(m, geom):
src/geouned/georeverse/modules/utils/booleanFunction.py:def is_integer(x):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def __init__(self, val=None, S1=None, S2=None):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def get_transpose(self):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def get_dependence(self):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def __init__(self):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def __str__(self):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def add_element(self, k1, k2, val):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def fill_missing_elements(self):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def get_out_surfaces(self):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def get_constraint_set(self, valname):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    def solid_in_box(self, Seq):  #  Sequence of the cell
src/geouned/georeverse/modules/utils/BooleanSolids.py:def combine_diag_elements(d1, d2):
src/geouned/georeverse/modules/utils/BooleanSolids.py:def build_c_table_from_solids(Box, SurfInfo, option="diag"):
src/geouned/georeverse/modules/utils/BooleanSolids.py:def remove_extra_surfaces(CellSeq, CTable):
src/geouned/georeverse/modules/utils/BooleanSolids.py:    # checking is make on solid cell definition to be removed from void cell
src/geouned/georeverse/modules/utils/BooleanSolids.py:                # get reduced definition
src/geouned/georeverse/modules/utils/BooleanSolids.py:def split_solid_fast(solid, surf, box):
src/geouned/georeverse/modules/utils/BooleanSolids.py:def point_inside(solid):
src/geouned/georeverse/modules/utils/BooleanSolids.py:def cut_box(Box):
src/geouned/georeverse/modules/utils/BooleanSolids.py:def check_sign(solid, surf):
src/geouned/georeverse/modules/objects.py:    def __init__(self, stringCell=None):
src/geouned/georeverse/modules/objects.py:            self.definition = None
src/geouned/georeverse/modules/objects.py:            self.__defTerms__ = None
src/geouned/georeverse/modules/objects.py:            self.__defTerms__ = None
src/geouned/georeverse/modules/objects.py:            self.__set_definition__(stringCell)
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:        if type(self.definition) is Cline:
src/geouned/georeverse/modules/objects.py:            cpCell.definition = Cline(self.definition.str)
src/geouned/georeverse/modules/objects.py:        elif type(self.definition) is BoolSequence:
src/geouned/georeverse/modules/objects.py:            cpCell.definition = self.definition.copy()
src/geouned/georeverse/modules/objects.py:    def get_sub_cell(self, seq):
src/geouned/georeverse/modules/objects.py:        subCell.definition = seq.copy()
src/geouned/georeverse/modules/objects.py:        subCell.surfaceList = subCell.definition.get_surfaces_numbers()
src/geouned/georeverse/modules/objects.py:    #    def split(self,nparts=2):
src/geouned/georeverse/modules/objects.py:    #             newdef = ') ('.join(terms[i*nelemts:(i+1)*nelemts])
src/geouned/georeverse/modules/objects.py:    #             newdef = '({})'.format(newdef)
src/geouned/georeverse/modules/objects.py:    #             subDefList.append(newdef)
src/geouned/georeverse/modules/objects.py:    #          newdef = ') ('.join(terms[(nparts-1)*nelemts:])
src/geouned/georeverse/modules/objects.py:    #          newdef = '({})'.format(newdef)
src/geouned/georeverse/modules/objects.py:    #          subDefList.append(newdef)
src/geouned/georeverse/modules/objects.py:    #             newdef = '):('.join(terms[i*nelemts:(i+1)*nelemts])
src/geouned/georeverse/modules/objects.py:    #             newdef = '({})'.format(newdef)
src/geouned/georeverse/modules/objects.py:    #             subDefList.append(newdef)
src/geouned/georeverse/modules/objects.py:    #          newdef = '):('.join(terms[(nparts-1)*nelemts:])
src/geouned/georeverse/modules/objects.py:    #          newdef = '({})'.format(newdef)
src/geouned/georeverse/modules/objects.py:    #          subDefList.append(newdef)
src/geouned/georeverse/modules/objects.py:    #           subCell.definition= Cline(df)
src/geouned/georeverse/modules/objects.py:    #           subCell.surfaceList  = subCell.definition.get_surfaces_numbers()
src/geouned/georeverse/modules/objects.py:    def get_outer_terms(self):
src/geouned/georeverse/modules/objects.py:        if not self.__defTerms__:
src/geouned/georeverse/modules/objects.py:            self.__defTerms__, self.__operator__ = outer_terms(self.definition.str)
src/geouned/georeverse/modules/objects.py:        return self.__defTerms__, self.__operator__
src/geouned/georeverse/modules/objects.py:    def make_box(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def build_shape(
src/geouned/georeverse/modules/objects.py:    def build_surface_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def transform_solid(self, matrix, reverse=False):
src/geouned/georeverse/modules/objects.py:    def transform_surfaces(self, matrix):
src/geouned/georeverse/modules/objects.py:    def set_surfaces(self, Surfaces):
src/geouned/georeverse/modules/objects.py:    def clean_undefined(self):
src/geouned/georeverse/modules/objects.py:        undefined = []
src/geouned/georeverse/modules/objects.py:        for s in self.definition.get_surfaces_numbers():
src/geouned/georeverse/modules/objects.py:                undefined.append(s)
src/geouned/georeverse/modules/objects.py:        if undefined:
src/geouned/georeverse/modules/objects.py:            self.definition.remove_surface(undefined)
src/geouned/georeverse/modules/objects.py:        for s in undefined:
src/geouned/georeverse/modules/objects.py:    def __set_definition__(self, stringCell):
src/geouned/georeverse/modules/objects.py:        self.definition = stringCell.geom
src/geouned/georeverse/modules/objects.py:        self.definition.remove_comments(full=True)
src/geouned/georeverse/modules/objects.py:        self.definition.remove_cr()
src/geouned/georeverse/modules/objects.py:        self.definition.remove_multispace()
src/geouned/georeverse/modules/objects.py:        self.definition.remove_redundant()
src/geouned/georeverse/modules/objects.py:        self.surfaceList = self.definition.get_surfaces_numbers()
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None):
src/geouned/georeverse/modules/objects.py:    def __str__(self):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None, truncated=False):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None, truncated=False):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None, truncated=False):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id, params, tr=None):
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:class Undefined:
src/geouned/georeverse/modules/objects.py:    def __init__(self, Id):
src/geouned/georeverse/modules/objects.py:        self.type = "Undefined"
src/geouned/georeverse/modules/objects.py:    def copy(self):
src/geouned/georeverse/modules/objects.py:        return Undefined(self.id)
src/geouned/georeverse/modules/objects.py:    def build_shape(self, boundBox):
src/geouned/georeverse/modules/objects.py:    def transform(self, matrix):
src/geouned/georeverse/modules/objects.py:def fuse_solid(parts):
src/geouned/georeverse/modules/objects.py:def make_hyperboloid(center, radii, rAxes, axis, onesht, length):
src/geouned/georeverse/modules/objects.py:def make_hyperbolic_cylinder(center, radii, rAxes, axis, length):
src/geouned/georeverse/modules/objects.py:def make_elliptic_cylinder(center, radii, rAxes, axis, length):
src/geouned/georeverse/modules/objects.py:def make_ellipsoid(center, radii, rAxes, axis):
src/geouned/georeverse/modules/objects.py:def make_elliptic_torus(R, RZ, RX, center, ZAxis):
src/geouned/georeverse/modules/objects.py:def make_paraboloid(center, axis, focal, length):
src/geouned/georeverse/modules/objects.py:def make_elliptic_cone(apex, axis, Ra, radii, rAxes, length):
src/geouned/georeverse/modules/objects.py:def orto_vect(v):
src/geouned/georeverse/modules/remh.py:# define patterns to be found in string #
src/geouned/georeverse/modules/remh.py:def remove_dollar(string):
src/geouned/georeverse/modules/remh.py:def redundant(m, geom):
src/geouned/georeverse/modules/remh.py:    # cell defined with surface. Theses parentheses are not redundants
src/geouned/georeverse/modules/remh.py:def chgsign(m):
src/geouned/georeverse/modules/remh.py:def repl_inter_union(m):
src/geouned/georeverse/modules/remh.py:def reverse_repl(m):
src/geouned/georeverse/modules/remh.py:def complementary(ccell, outter=True):
src/geouned/georeverse/modules/remh.py:    def __init__(self, line):
src/geouned/georeverse/modules/remh.py:    def copy(self):
src/geouned/georeverse/modules/remh.py:    def get_surfaces_numbers(self):
src/geouned/georeverse/modules/remh.py:    def remove_multispace(self):
src/geouned/georeverse/modules/remh.py:    def remove_cr(self):
src/geouned/georeverse/modules/remh.py:    def remove_comments(self, full=False):
src/geouned/georeverse/modules/remh.py:        kept in the line if 'full' option is False (default)"""
src/geouned/georeverse/modules/remh.py:    def restore_comments(self):
src/geouned/georeverse/modules/remh.py:    def outer_terms(self):
src/geouned/georeverse/modules/remh.py:    def remove_redundant(self, remove_com=True, remopt="nochg"):
src/geouned/georeverse/modules/remh.py:    def get_hashcell(self, start=0):
src/geouned/georeverse/modules/remh.py:        """get the complementary cell defined with surfaces combination"""
src/geouned/georeverse/modules/remh.py:    def replace(self, surf, new, pos=0):
src/geouned/georeverse/modules/remh.py:    def count_p(self):
src/geouned/georeverse/modules/remh.py:    def split_cell(self):
src/geouned/georeverse/modules/remh.py:    def __init__(self, card):
src/geouned/georeverse/modules/remh.py:    def __card_split__(self, cardin):
src/geouned/georeverse/modules/remh.py:           - geom    : Cline class containing the part of the geometric definition of the cell
src/geouned/georeverse/modules/remh.py:    def __get_data__(self):
src/geouned/georeverse/modules/remh.py:    def get_stat(self, remove_com=True):
src/geouned/georeverse/modules/remh.py:    def get_lines(self):
src/geouned/georeverse/modules/remh.py:def remove_hash(cards, cname, keepComments=True):
src/geouned/georeverse/modules/remh.py:    def remove(card, cname, keepComments):
src/geouned/georeverse/modules/remh.py:            if m.group(1) == "(":  # complementary cell defined as surface intersections
src/geouned/georeverse/modules/remh.py:                )  # complementary cell defined with other cell index
src/geouned/georeverse/modules/remh.py:                newdef = remove(
src/geouned/georeverse/modules/remh.py:                    + complementary(newdef)
src/geouned/georeverse/modules/mcnp_input.py:    def __init__(self, name):
src/geouned/georeverse/modules/mcnp_input.py:    def get_filtered_cells(self, Surfaces, config):
src/geouned/georeverse/modules/mcnp_input.py:    def get_level_structure(self):
src/geouned/georeverse/modules/mcnp_input.py:        set_explicitcell_definition(cellCards)
src/geouned/georeverse/modules/mcnp_input.py:    def get_cells(self, U=None, Fill=None):
src/geouned/georeverse/modules/mcnp_input.py:    def get_surfaces(self, scale=1.0):
src/geouned/georeverse/modules/mcnp_input.py:    def __getTransList__(self):
src/geouned/georeverse/modules/mcnp_input.py:def get_trans_matrix(trsf, unit="", scale=10.0):
src/geouned/georeverse/modules/mcnp_input.py:def substitute_like_cell(universe, Surfaces):
src/geouned/georeverse/modules/mcnp_input.py:def select_cells(cellList, config):
src/geouned/georeverse/modules/mcnp_input.py:# Change implicit cell definition (like-but type or cell with #)
src/geouned/georeverse/modules/mcnp_input.py:# to explicit cell definition (only surface number)
src/geouned/georeverse/modules/mcnp_input.py:def set_explicitcell_definition(universeCells):
src/geouned/georeverse/modules/mcnp_input.py:def process_surfaces(UCells, Surfaces):
src/geouned/georeverse/modules/mcnp_input.py:def get_trans_matrix(trsf, unit="", scale=10.0):
src/geouned/georeverse/modules/mcnp_input.py:def transformation_matrix(TRSF, Transformations):
src/geouned/georeverse/modules/mcnp_input.py:def get_sub_universes(Ustart, Universes):
src/geouned/georeverse/modules/mcnp_input.py:# traduce mcnp surface definition for Solid_Cell class
src/geouned/georeverse/modules/mcnp_input.py:def get_primitive_surfaces(mcnp_surfaces, scale=10.0):
src/geouned/georeverse/modules/mcnp_input.py:                    "not implemented surfaces defined by point with more than 2couples of value"
src/geouned/georeverse/modules/mcnp_input.py:                    "not implemented surfaces defined by point with more than 2couples of value"
src/geouned/georeverse/modules/mcnp_input.py:                    "not implemented surfaces defined by point with more than 2couples of value"
src/geouned/georeverse/modules/mcnp_input.py:            print("Undefined", Sid, Stype)
src/geouned/georeverse/modules/mcnp_input.py:def points_to_coeffs(scf):
src/geouned/georeverse/modules/mcnp_input.py:def get_parabola_parameters(eVal, eVect, T, U):
src/geouned/georeverse/modules/mcnp_input.py:def get_cylinder_parameters(eVal, eVect, T, k, iaxis):
src/geouned/georeverse/modules/mcnp_input.py:        minorAxis = FreeCAD.Vector(eVect.T[iMin])  # define axis in global geometry
src/geouned/georeverse/modules/mcnp_input.py:def get_cone_parameters(eVal, eVect, T, iaxis):
src/geouned/georeverse/modules/mcnp_input.py:def get_hyperboloid_parameters(eVal, eVect, T, k, iaxis):
src/geouned/georeverse/modules/mcnp_input.py:    minorAxis = FreeCAD.Vector(eVect.T[other])  # define axis in global geometry
src/geouned/georeverse/modules/mcnp_input.py:def get_ellipsoid_parameters(eVal, eVect, T, k):
src/geouned/georeverse/modules/mcnp_input.py:def get_gq_axis(eVal, k):
src/geouned/georeverse/modules/mcnp_input.py:def sq_2_params(params):
src/geouned/georeverse/modules/mcnp_input.py:def gq_2_params(x):
src/geouned/georeverse/modules/mcnp_input.py:def conic_surface(eVal, vect, T, U):
src/geouned/georeverse/modules/process_inp.py:def set_options(optionFile):
src/geouned/georeverse/modules/process_inp.py:def get_setting(config):
src/geouned/georeverse/modules/process_inp.py:def get_level(config):
src/geouned/georeverse/modules/process_inp.py:def get_range(section, config):
src/geouned/georeverse/modules/process_inp.py:def get_box_data(string):
src/geouned/georeverse/modules/process_inp.py:def get_range_data(rawData):
src/geouned/georeverse/modules/process_inp.py:                print("bad range definition")
src/geouned/georeverse/modules/process_inp.py:                        print("bad range definition")
src/geouned/georeverse/modules/process_inp.py:                    print("bad range definition")
src/geouned/georeverse/modules/process_inp.py:def set_sec_options(config):
src/geouned/georeverse/modules/process_inp.py:def range_generator(intervals):
src/geouned/georeverse/modules/xml_input.py:    def __init__(self, name):
src/geouned/georeverse/modules/xml_input.py:    def get_filtered_cells(self, Surfaces, config):
src/geouned/georeverse/modules/xml_input.py:    def get_level_structure(self):
src/geouned/georeverse/modules/xml_input.py:    def get_cells(self, U=None, Fill=None):
src/geouned/georeverse/modules/xml_input.py:    def get_surfaces(self, scale=1.0):
src/geouned/georeverse/modules/xml_input.py:def select_cells(cellList, config):
src/geouned/georeverse/modules/xml_input.py:def process_surfaces(UCells, Surfaces):
src/geouned/georeverse/modules/xml_input.py:def get_sub_universes(Ustart, Universes):
src/geouned/georeverse/modules/xml_input.py:# traduce mcnp surface definition for Solid_Cell class
src/geouned/georeverse/modules/xml_input.py:def get_primitive_surfaces(mcnp_surfaces, scale=10.0):
src/geouned/georeverse/modules/xml_input.py:            print("Undefined", Sid)
src/geouned/georeverse/modules/xml_input.py:def gq_2_cyl(x):
src/geouned/georeverse/modules/xml_parser.py:    def __init__(self, data):
src/geouned/georeverse/modules/xml_parser.py:    def process_data(self, data):
src/geouned/georeverse/modules/xml_parser.py:    def __init__(self, data):
src/geouned/georeverse/modules/xml_parser.py:    def process_data(self, data):
src/geouned/georeverse/modules/xml_parser.py:def get_cards(root):
src/geouned/georeverse/modules/xml_parser.py:def process_card(card):
src/geouned/georeverse/modules/parser/parser.py:    # This clause define the fallback for cPickle, which is an accelerated
src/geouned/georeverse/modules/parser/parser.py:def fmt_gen(s):
src/geouned/georeverse/modules/parser/parser.py:    There are two levels of card types. 1-st level is purely defined by card
src/geouned/georeverse/modules/parser/parser.py:    Data cards can be of different type that is defined by the card's first
src/geouned/georeverse/modules/parser/parser.py:    def get_name(cls, cid):
src/geouned/georeverse/modules/parser/parser.py:    def __init__(self, lines, ctype, pos, debug=None):
src/geouned/georeverse/modules/parser/parser.py:        # some properties defined on demand
src/geouned/georeverse/modules/parser/parser.py:        self.__u = -1  # -1 means undefined. None -- not specified in input
src/geouned/georeverse/modules/parser/parser.py:        self.__st = ""  # '' means undefined.
src/geouned/georeverse/modules/parser/parser.py:    def _get_value_by_type(self, t):
src/geouned/georeverse/modules/parser/parser.py:    def _set_value_by_type(self, t, v):
src/geouned/georeverse/modules/parser/parser.py:    def geom_prefix(self):
src/geouned/georeverse/modules/parser/parser.py:    def geom_prefix(self, value):
src/geouned/georeverse/modules/parser/parser.py:    def geom_suffix(self):
src/geouned/georeverse/modules/parser/parser.py:    def geom_suffix(self, value):
src/geouned/georeverse/modules/parser/parser.py:    def print_debug(self, comment, key="tihv"):
src/geouned/georeverse/modules/parser/parser.py:    def get_input(self, check_bad_chars=False):
src/geouned/georeverse/modules/parser/parser.py:            # TODO: dtype and name of the card can be defined already here.
src/geouned/georeverse/modules/parser/parser.py:    def _protect_nums(self):
src/geouned/georeverse/modules/parser/parser.py:    def get_values(self):
src/geouned/georeverse/modules/parser/parser.py:    def get_refcells(self):
src/geouned/georeverse/modules/parser/parser.py:        Returns all cells used in definition of self.
src/geouned/georeverse/modules/parser/parser.py:    def get_geom(self):
src/geouned/georeverse/modules/parser/parser.py:    def get_u(self):
src/geouned/georeverse/modules/parser/parser.py:    def get_m(self):
src/geouned/georeverse/modules/parser/parser.py:    def get_d(self):
src/geouned/georeverse/modules/parser/parser.py:    def set_d(self, v):
src/geouned/georeverse/modules/parser/parser.py:    def get_f(self, newv=None, trsf=False):
src/geouned/georeverse/modules/parser/parser.py:    def get_imp(self, vals={}):
src/geouned/georeverse/modules/parser/parser.py:    def remove_fill(self):
src/geouned/georeverse/modules/parser/parser.py:    def card(self, wrap=False, comment=True):
src/geouned/georeverse/modules/parser/parser.py:    def remove_spaces(self):
src/geouned/georeverse/modules/parser/parser.py:    def apply_map(self, f):
src/geouned/georeverse/modules/parser/parser.py:# def _parse_geom(geom):
src/geouned/georeverse/modules/parser/parser.py:def _split_cell(input_, self):
src/geouned/georeverse/modules/parser/parser.py:def _split_surface(input_):
src/geouned/georeverse/modules/parser/parser.py:    # define coefficients
src/geouned/georeverse/modules/parser/parser.py:def _get_int(s):
src/geouned/georeverse/modules/parser/parser.py:def _parse_tr(input_):
src/geouned/georeverse/modules/parser/parser.py:def _split_data(input_):
src/geouned/georeverse/modules/parser/parser.py:        # additional tests to define data card type:
src/geouned/georeverse/modules/parser/parser.py:        # define type of integers by tally type:
src/geouned/georeverse/modules/parser/parser.py:def is_commented(l):
src/geouned/georeverse/modules/parser/parser.py:def is_fc_card(l):
src/geouned/georeverse/modules/parser/parser.py:def is_blankline(l):
src/geouned/georeverse/modules/parser/parser.py:    def get_cards(inp, debug=None, preservetabs=False):
src/geouned/georeverse/modules/parser/parser.py:    def get_cards(inp, debug=None, preservetabs=False):
src/geouned/georeverse/modules/parser/parser.py:def index_(line, chars="$&"):
src/geouned/georeverse/modules/parser/parser.py:def get_cards_from_input(inp, debug=None, preservetabs=False):
src/geouned/georeverse/modules/parser/parser.py:    def _yield(card, ct, ln):
src/geouned/georeverse/modules/parser/parser.py:    def replace_tab(l, cln, preserve=False, ts=8):
src/geouned/georeverse/modules/parser/parser.py:        # define the first block:
src/geouned/georeverse/modules/parser/parser.py:        # defined by the line itself (5 spaces), or by previous lines (message
src/geouned/georeverse/modules/parser/parser.py:def get_blocks(cards):
src/geouned/georeverse/modules/parser/parser.py:def are_close_vals(x, y, re=1e-6, ra=0.0):
src/geouned/georeverse/modules/parser/parser.py:def are_close_lists(x, y, re=1e-6, pci=[]):
src/geouned/georeverse/modules/parser/parser.py:    # pci -- list of indices that define elements of x and y to be checked for
src/geouned/georeverse/modules/parser/PartialFormatter.py:def make_label(item):
src/geouned/georeverse/modules/parser/PartialFormatter.py:    def __getitem__(self, item):
src/geouned/georeverse/modules/parser/PartialFormatter.py:    def __missing__(self, key):
src/geouned/georeverse/modules/parser/PartialFormatter.py:    def format(*args, **kwargs):
src/geouned/georeverse/modules/parser/PartialFormatter.py:    def _vformat(
src/geouned/georeverse/reverse.py:def reverse(optFile="configRevese.ini"):
src/geouned/georeverse/reverse.py:    # get geometry definition from mcnp input
src/geouned/georeverse/reverse.py:def print_code_version():
tests/test_volumes.py:def test_volumes(input_step_file):
tests/test_transport.py:def test_transport(input_step_file):
tests/test_convert.py:def test_conversion(input_step_file):
tests/test_convert.py:        "vol_sdef = True\n"
.git/hooks/update.sample:#   repository.  By default they won't be.
.git/hooks/update.sample:#   repository.  By default they won't be.
.git/hooks/update.sample:#   This boolean sets whether a tag may be modified after creation. By default
.git/hooks/update.sample:#   repository.  By default they won't be.
.git/hooks/update.sample:#   in the repository.  By default this is allowed.
.git/hooks/push-to-checkout.sample:# By default, such a push is refused if the working tree and the index
.git/hooks/push-to-checkout.sample:# of the branch. This hook is to be used to override the default
.git/hooks/push-to-checkout.sample:# behaviour; however the code below reimplements the default behaviour
.git/hooks/push-to-checkout.sample:# for the default behaviour for git's push-to-checkout hook defined in
.git/hooks/pre-rebase.sample:					undef $msg;
